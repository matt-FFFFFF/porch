var relearn_searchindex = [
  {
    "breadcrumb": "Porch Documentation \u003e Advanced Topics",
    "content": "Circular Dependency Detection Overview The porch configuration system now includes robust circular dependency detection to prevent infinite loops in command group references. This feature helps catch configuration errors early and provides clear error messages to help debug issues.\nFeatures 1. Circular Dependency Detection The system detects several types of circular dependencies:\nSimple circular dependencies: Group A references Group B, which references Group A Multi-way circular dependencies: Group A → Group B → Group C → Group A Self-referencing groups: A group that references itself Deep nested cycles: Circular dependencies buried deep in nested command structures 2. Maximum Recursion Depth Protection To prevent stack overflow and excessive processing, the system enforces a maximum recursion depth of 100 levels when resolving command groups.\n3. Enhanced Error Messages When a circular dependency is detected, the system provides clear error messages showing:\nThe exact circular path (e.g., “group_a → group_b → group_a”) Which command within a group caused the issue The command index for easier debugging 4. Context Cancellation Support Configuration building now respects context cancellation, allowing for:\nGraceful interruption with Ctrl+C during config parsing Timeout protection (30-second default for config building) Responsive signal handling during long configuration processes Examples Detecting Circular Dependencies Example 1: Simple Circular Dependency\nname: infinite loop example command_groups: - name: group_one commands: - type: serial name: reference to two command_group: group_two - name: group_two commands: - type: serial name: reference to one command_group: group_one commands: - type: parallel name: start command_group: group_one Error Output:\nfailed to build config: invalid command group 'group_one': in command 0 of group group_one: circular dependency detected: group_one → group_two → group_one Example 2: Self-Referencing Group\nname: self reference example command_groups: - name: recursive_group commands: - type: shell name: first command command_line: echo \"first\" - type: serial name: self reference command_group: recursive_group commands: - type: serial name: start command_group: recursive_group Error Output:\nfailed to build config: invalid command group 'recursive_group': in command 1 of group recursive_group: circular dependency detected: recursive_group → recursive_group Valid Nested Groups This configuration is valid and will work correctly:\nname: valid nested example command_groups: - name: setup commands: - type: shell name: prepare command_line: echo \"preparing\" - type: serial name: run tests command_group: test_suite - name: test_suite commands: - type: shell name: unit tests command_line: echo \"running unit tests\" - type: serial name: cleanup command_group: cleanup - name: cleanup commands: - type: shell name: clean up command_line: echo \"cleaning up\" commands: - type: serial name: main workflow command_group: setup Signal Handling Improvements Configuration Building Timeout Configuration building now has a 30-second timeout to prevent hanging on malformed configurations:\n// In cmd/porch/run/run.go configCtx, configCancel := context.WithTimeout(ctx, 30*time.Second) defer configCancel() rb, err := config.BuildFromYAML(configCtx, factory, bytes) Context Cancellation Checks The system now checks for context cancellation at key points:\nBefore starting configuration parsing After command group validation During individual command processing Graceful Interruption When you press Ctrl+C during configuration building, you’ll see:\nfailed to build config: configuration building timed out: context canceled Implementation Details Registry-Level Detection The commandregistry.Registry now includes:\nresolveCommandGroupWithDepth(): Tracks recursion depth and visiting state validateCommandForCircularDeps(): Validates individual commands for group references formatCircularDependencyPath(): Creates human-readable circular dependency paths Configuration-Level Validation The config.BuildFromYAML() function:\nValidates all command groups before proceeding with command creation Includes context cancellation checks throughout the process Provides detailed error messages with command indices Error Types New error types have been added:\nErrCircularDependency: For circular dependency detection ErrConfigurationTimeout: For configuration timeout handling ErrMaxRecursionDepth: For recursion depth protection Testing Comprehensive tests have been added covering:\nSimple circular dependencies Multi-way circular dependencies Self-referencing groups Maximum recursion depth Context cancellation Configuration timeouts Run tests with:\ngo test ./internal/config -v -run TestCircularDependencyDetection go test ./internal/config -v -run TestConfigurationTimeout go test ./internal/commandregistry -v",
    "description": "Circular Dependency Detection Overview The porch configuration system now includes robust circular dependency detection to prevent infinite loops in command group references. This feature helps catch configuration errors early and provides clear error messages to help debug issues.\nFeatures 1. Circular Dependency Detection The system detects several types of circular dependencies:",
    "tags": [],
    "title": "Circular Dependency Detection",
    "uri": "/porch/advanced/circular-dependency-detection/index.html"
  },
  {
    "breadcrumb": "Porch Documentation",
    "content": "Getting Started with Porch This section covers the fundamental concepts you need to understand before building workflows with Porch.\nWhy Use Porch? Porch was designed to solve several common challenges in command orchestration:\nPortability Run the same workflows across different environments:\nLocal Development: Test and debug workflows on your local machine CI/CD Pipelines: Execute workflows in continuous integration environments Production Servers: Deploy and run workflows consistently across servers Unlike shell scripts that depend on specific shell implementations or system utilities, Porch provides a consistent execution environment.\nSimplicity Define complex workflows using simple, readable YAML:\nNo need to learn complex scripting languages Clear, declarative syntax Easy to version control and review Self-documenting workflow definitions Reliability Built-in error handling and flow control:\nGraceful shutdown on interruption (SIGINT/SIGTERM) Conditional execution based on exit codes Comprehensive error reporting Skip controls for non-critical failures Visibility Real-time monitoring and detailed results:\nInteractive TUI for live progress tracking Hierarchical tree visualization of command execution Detailed execution metrics and timing Structured output in JSON format Core Concepts Workflows A workflow is a collection of commands defined in a YAML file. Each workflow has:\nName: A descriptive name for the workflow Description: Optional explanation of what the workflow does Commands: List of commands to execute Command Groups: Optional reusable command sets Example:\nname: \"My Workflow\" description: \"A simple example workflow\" commands: - type: \"shell\" name: \"Hello World\" command_line: \"echo 'Hello, World!'\" Commands Commands are the building blocks of workflows. Porch supports several command types:\nshell: Execute shell commands pwsh: Execute PowerShell scripts serial: Run commands sequentially parallel: Run commands concurrently foreachdirectory: Execute commands in multiple directories copycwdtotemp: Copy working directory to a temporary location Each command type has specific attributes and behaviors. See the Commands section for details.\nExecution Flow Commands execute in the order defined, with support for:\nSequential Execution: Commands run one after another (serial) Parallel Execution: Commands run simultaneously (parallel) Nested Batches: Combine serial and parallel execution for complex flows Conditional Execution: Run commands based on previous results Next Steps Learn about the key features that make Porch powerful:\nPath Inheritance - How working directories are resolved Flow Control - Skipping commands and handling errors",
    "description": "Getting Started with Porch This section covers the fundamental concepts you need to understand before building workflows with Porch.\nWhy Use Porch? Porch was designed to solve several common challenges in command orchestration:\nPortability Run the same workflows across different environments:",
    "tags": [],
    "title": "Getting Started",
    "uri": "/porch/basics/index.html"
  },
  {
    "breadcrumb": "Porch Documentation \u003e Commands",
    "content": "Shell Command The shell command executes shell commands with full environment control and configurable exit code handling.\nAttributes Required type: \"shell\": Identifies this as a shell command name: Descriptive name for the command command_line: The shell command to execute Optional working_directory: Directory to execute the command in (inherits from parent if not specified) env: Environment variables as key-value pairs runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution success_exit_codes: Exit codes indicating success (defaults to [0]) skip_exit_codes: Exit codes that skip remaining commands Basic Example name: \"Simple Build\" commands: - type: \"shell\" name: \"Build Application\" command_line: \"go build -o app .\" Complete Example name: \"Advanced Shell Command\" commands: - type: \"shell\" name: \"Build Go Application\" command_line: \"go build -ldflags='-s -w' -o dist/app .\" working_directory: \"/path/to/project\" env: CGO_ENABLED: \"0\" GOOS: \"linux\" GOARCH: \"amd64\" success_exit_codes: [0] skip_exit_codes: [2] runs_on_condition: \"success\" Environment Variables Environment variables are inherited from:\nThe system environment Parent command’s environment The command’s own env settings (takes precedence) env: GLOBAL_VAR: \"global\" commands: - type: \"serial\" name: \"Build Process\" env: BUILD_TYPE: \"release\" commands: - type: \"shell\" name: \"Compile\" command_line: \"make build\" env: OPTIMIZATION: \"O3\" # This command sees: GLOBAL_VAR, BUILD_TYPE, and OPTIMIZATION Exit Code Handling Success Codes Define which exit codes indicate success:\n- type: \"shell\" name: \"Tolerant Lint\" command_line: \"golangci-lint run\" success_exit_codes: [0, 1] # Exit codes 0 and 1 are both considered successful Skip Codes Exit codes that skip remaining commands in the batch:\n- type: \"shell\" name: \"Check for Skip Condition\" command_line: | if [ -z \"$DEPLOY_KEY\" ]; then echo \"DEPLOY_KEY not set. Skipping deployment.\" 1\u003e\u00262 exit 99 fi skip_exit_codes: [99] Using Redirection Porch captures stdout and stderr automatically. Use redirection to control output:\n# Output to stderr - type: \"shell\" name: \"Warning Message\" command_line: \"echo 'Warning: Low disk space' 1\u003e\u00262\" # Conditional output to stderr with skip - type: \"shell\" name: \"Check Prerequisites\" command_line: | if [ -z \"$FOO\" ]; then echo \"FOO is not set. Skipping\" 1\u003e\u00262 exit 99 fi skip_exit_codes: [99] By default, stderr is displayed in results if the step fails or returns a skippable exit code.\nMulti-line Commands Use YAML multi-line strings for complex commands:\n- type: \"shell\" name: \"Complex Build Script\" command_line: | set -e echo \"Starting build...\" npm install npm run lint npm run build npm run test echo \"Build completed successfully\" Conditional Execution Run commands based on previous results:\ncommands: - type: \"shell\" name: \"Build\" command_line: \"make build\" - type: \"shell\" name: \"Deploy on Success\" command_line: \"./deploy.sh\" runs_on_condition: \"success\" - type: \"shell\" name: \"Cleanup on Error\" command_line: \"make clean\" runs_on_condition: \"error\" - type: \"shell\" name: \"Always Send Notification\" command_line: \"notify.sh\" runs_on_condition: \"always\" Common Patterns Build with Environment Variables - type: \"shell\" name: \"Cross-Platform Build\" command_line: \"go build -o dist/app-$GOOS-$GOARCH\" env: CGO_ENABLED: \"0\" GOOS: \"linux\" GOARCH: \"amd64\" Script Execution - type: \"shell\" name: \"Run Deployment Script\" command_line: \"./scripts/deploy.sh production\" working_directory: \"/app\" Pipeline with Skip - type: \"shell\" name: \"Check Condition\" command_line: | if [ \"$SKIP_TESTS\" == \"true\" ]; then echo \"Tests skipped by user\" 1\u003e\u00262 exit 100 fi skip_exit_codes: [100] - type: \"shell\" name: \"Run Tests\" command_line: \"npm test\" # Skipped if previous command exits with 100 Best Practices Use explicit exit codes: Define success_exit_codes for commands with non-standard success codes Set working directory: Use working_directory instead of cd in commands Use environment variables: Prefer env over hardcoded values Redirect important messages: Send warnings and skip messages to stderr Use multi-line for complex scripts: Makes commands more readable Handle errors gracefully: Use skip_exit_codes for optional steps Related Flow Control - Learn about skip codes and conditional execution Path Inheritance - Understand how working directories are resolved Serial Command - Execute shell commands sequentially Parallel Command - Execute shell commands concurrently",
    "description": "Shell Command The shell command executes shell commands with full environment control and configurable exit code handling.\nAttributes Required type: \"shell\": Identifies this as a shell command name: Descriptive name for the command command_line: The shell command to execute Optional working_directory: Directory to execute the command in (inherits from parent if not specified) env: Environment variables as key-value pairs runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution success_exit_codes: Exit codes indicating success (defaults to [0]) skip_exit_codes: Exit codes that skip remaining commands Basic Example name: \"Simple Build\" commands: - type: \"shell\" name: \"Build Application\" command_line: \"go build -o app .\" Complete Example name: \"Advanced Shell Command\" commands: - type: \"shell\" name: \"Build Go Application\" command_line: \"go build -ldflags='-s -w' -o dist/app .\" working_directory: \"/path/to/project\" env: CGO_ENABLED: \"0\" GOOS: \"linux\" GOARCH: \"amd64\" success_exit_codes: [0] skip_exit_codes: [2] runs_on_condition: \"success\" Environment Variables Environment variables are inherited from:",
    "tags": [],
    "title": "Shell Command",
    "uri": "/porch/commands/shell/index.html"
  },
  {
    "breadcrumb": "Porch Documentation",
    "content": "Command Types Porch provides six built-in command types for different execution patterns. Each command type serves a specific purpose and has its own configuration options.\nOverview Command Type Purpose Execution Mode Shell Execute shell commands Single PowerShell Execute PowerShell scripts Single Serial Run commands sequentially Container Parallel Run commands concurrently Container ForEach Directory Execute commands in multiple directories Container Copy to Temp Copy working directory to temporary location Utility Single Commands Single commands execute a single task:\nShell: Execute any shell command or script PowerShell: Execute PowerShell scripts (Windows, Linux, macOS) Container Commands Container commands group and control the execution of other commands:\nSerial: Execute commands one after another Parallel: Execute commands simultaneously ForEach Directory: Execute commands for each directory found Utility Commands Utility commands provide special functionality:\nCopy to Temp: Create isolated temporary environments Common Attributes All commands share these common attributes:\ntype (required): The command type name (required): Descriptive name for the command working_directory (optional): Working directory for execution env (optional): Environment variables as key-value pairs runs_on_condition (optional): When to run (success, error, always, exit-codes) runs_on_exit_codes (optional): Specific exit codes that trigger execution See individual command pages for type-specific attributes and detailed examples.",
    "description": "Command Types Porch provides six built-in command types for different execution patterns. Each command type serves a specific purpose and has its own configuration options.\nOverview Command Type Purpose Execution Mode Shell Execute shell commands Single PowerShell Execute PowerShell scripts Single Serial Run commands sequentially Container Parallel Run commands concurrently Container ForEach Directory Execute commands in multiple directories Container Copy to Temp Copy working directory to temporary location Utility Single Commands Single commands execute a single task:",
    "tags": [],
    "title": "Commands",
    "uri": "/porch/commands/index.html"
  },
  {
    "breadcrumb": "Porch Documentation \u003e Getting Started",
    "content": "Path Inheritance One of Porch’s most powerful features is its intelligent handling of working directories through path inheritance. This allows you to build complex workflows where commands naturally inherit and modify their working directory context.\nHow It Works Porch uses a recursive dynamic programming approach to resolve working directories. Each command’s working directory is determined by combining its own working_directory setting with its parent’s resolved directory.\nResolution Rules The GetCwd() method resolves working directories using these rules:\nNil receiver: Returns \".\" Empty cwd, no parent: Returns \".\" Empty cwd, has parent: Inherits parent’s cwd Absolute path: Returns the path directly (no inheritance) Relative path, no parent: Returns the relative path Relative path, has parent: Joins with parent’s cwd using filepath.Join() This creates a hierarchical resolution system where child commands automatically inherit their parent’s working directory unless they specify otherwise.\nDefault Behavior: Relative Paths By default, Porch uses relative paths for working directories. This means:\nChild commands inherit the parent’s working directory Relative paths are resolved against the parent’s directory The working directory “flows down” through the command hierarchy Example: Relative Paths name: \"Build Workflow\" commands: - type: \"serial\" name: \"Build Steps\" working_directory: \"./project\" commands: - type: \"shell\" name: \"Install Dependencies\" command_line: \"npm install\" # Runs in ./project (inherited) - type: \"shell\" name: \"Build Subpackage\" working_directory: \"packages/core\" command_line: \"npm run build\" # Runs in ./project/packages/core (joined with parent) - type: \"shell\" name: \"Run Tests\" working_directory: \"../..\" command_line: \"npm test\" # Runs in . (relative to ./project) In this example:\nThe first command runs in ./project The second command runs in ./project/packages/core The third command runs in . (going up two levels from ./project) Breaking Inheritance: Absolute Paths If you specify a command with an absolute path, it will not inherit from the parent. The absolute path is used directly.\nExample: Absolute Paths name: \"Multi-Project Build\" commands: - type: \"serial\" name: \"Build All Projects\" working_directory: \"./frontend\" commands: - type: \"shell\" name: \"Build Frontend\" command_line: \"npm run build\" # Runs in ./frontend (inherited) - type: \"shell\" name: \"Build Backend\" working_directory: \"/home/user/projects/backend\" command_line: \"go build\" # Runs in /home/user/projects/backend (absolute path) - type: \"shell\" name: \"Package Frontend\" command_line: \"tar -czf dist.tar.gz dist/\" # Runs in ./frontend (back to inherited path) In this example:\nFirst command: Uses ./frontend (inherited) Second command: Uses /home/user/projects/backend (absolute, breaks inheritance) Third command: Uses ./frontend (back to inherited path) Practical Examples Monorepo Structure name: \"Monorepo Tests\" commands: - type: \"foreachdirectory\" name: \"Test Each Package\" working_directory: \"./packages\" mode: \"parallel\" depth: 1 include_hidden: false working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Run Package Tests\" command_line: \"npm test\" # Each iteration runs in ./packages/\u003cpackage-name\u003e Nested Serial Execution name: \"Deployment Pipeline\" working_directory: \"./dist\" commands: - type: \"serial\" name: \"Prepare\" commands: - type: \"shell\" name: \"Clean\" command_line: \"rm -rf *\" # Runs in ./dist - type: \"shell\" name: \"Copy Assets\" working_directory: \"../src/assets\" command_line: \"cp -r . ../../dist/\" # Runs in ./src/assets Temporary Directory Workflow name: \"Isolated Build\" commands: - type: \"copycwdtotemp\" name: \"Copy to Temp\" working_directory: \"./src\" # Creates temp dir and copies ./src there # Sets absolute path to temp dir - type: \"shell\" name: \"Build in Isolation\" command_line: \"make build\" # Runs in the temp directory (absolute path from copycwdtotemp) - type: \"shell\" name: \"Copy Back Results\" working_directory: \"/original/path/dist\" command_line: \"cp ../build/* .\" # Runs in absolute path, independent of temp dir Key Takeaways Relative paths are inherited: Child commands inherit parent’s working directory Absolute paths break inheritance: Use absolute paths when you need to “escape” the hierarchy Empty paths inherit: If you don’t specify a working directory, you get the parent’s Path joining is automatic: Relative paths are joined with parent’s path using filepath.Join() Resolution is recursive: The algorithm walks up the command tree to resolve the final path This design makes it easy to:\nBuild hierarchical workflows with natural directory context Override paths when needed with absolute paths Keep workflows portable using relative paths Avoid repetitive path specifications Implementation Details The path resolution is implemented in internal/runbatch/base.go:\nfunc (c *BaseCommand) GetCwd() string { if c == nil { return \".\" } if c.cwd == \"\" { if c.parent == nil { return \".\" } return c.parent.GetCwd() } if filepath.IsAbs(c.cwd) { return c.cwd } if c.parent == nil { return c.cwd } return filepath.Join(c.parent.GetCwd(), c.cwd) } This recursive approach ensures efficient path resolution while maintaining clarity and simplicity.",
    "description": "Path Inheritance One of Porch’s most powerful features is its intelligent handling of working directories through path inheritance. This allows you to build complex workflows where commands naturally inherit and modify their working directory context.\nHow It Works Porch uses a recursive dynamic programming approach to resolve working directories. Each command’s working directory is determined by combining its own working_directory setting with its parent’s resolved directory.",
    "tags": [],
    "title": "Path Inheritance",
    "uri": "/porch/basics/path-inheritance/index.html"
  },
  {
    "breadcrumb": "Porch Documentation \u003e Commands",
    "content": "PowerShell Command The pwsh command executes PowerShell scripts with full environment control and configurable exit code handling. It works on Windows, Linux, and macOS.\nAttributes Required type: \"pwsh\": Identifies this as a PowerShell command name: Descriptive name for the command script OR script_file: PowerShell script content or path to script file (mutually exclusive) Optional working_directory: Directory to execute the command in env: Environment variables as key-value pairs runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution success_exit_codes: Exit codes indicating success (defaults to [0]) skip_exit_codes: Exit codes that skip remaining commands Inline Script Example name: \"PowerShell Inline\" commands: - type: \"pwsh\" name: \"Run PowerShell Script\" script: | Write-Host \"Starting PowerShell script...\" # Your PowerShell commands here Write-Host \"PowerShell script completed.\" Script File Example name: \"PowerShell File\" commands: - type: \"pwsh\" name: \"Run PowerShell File\" script_file: \"./scripts/deploy.ps1\" working_directory: \"/app\" Complete Example name: \"Advanced PowerShell Command\" commands: - type: \"pwsh\" name: \"Build and Deploy\" script: | Write-Host \"Building application...\" dotnet build -c Release Write-Host \"Running tests...\" dotnet test if ($LASTEXITCODE -ne 0) { Write-Error \"Tests failed\" exit 1 } Write-Host \"Deployment successful\" working_directory: \"/path/to/project\" env: DEPLOY_ENV: \"production\" API_KEY: \"secret-key\" success_exit_codes: [0] runs_on_condition: \"success\" Script vs Script File Use script for inline PowerShell code:\n- type: \"pwsh\" name: \"Inline Script\" script: | Write-Host \"Hello from PowerShell\" Get-ChildItem Use script_file to reference an external file:\n- type: \"pwsh\" name: \"External Script\" script_file: \"./scripts/build.ps1\" Note: script and script_file are mutually exclusive. Use one or the other.\nExit Code Handling PowerShell exit codes work the same as shell commands:\n- type: \"pwsh\" name: \"Flexible PowerShell\" script: | # Your PowerShell code if ($someCondition) { exit 0 # Success } else { exit 1 # Failure } success_exit_codes: [0] skip_exit_codes: [99] Best Practices Use Write-Host for output: Makes messages visible in Porch results Check $LASTEXITCODE: Verify exit codes of called commands Set working directory: Use working_directory attribute instead of Set-Location Use environment variables: Access via env attribute, read with $env:VAR_NAME Handle errors: Use exit to return appropriate codes Related Shell Command - Execute shell commands Flow Control - Conditional execution and error handling",
    "description": "PowerShell Command The pwsh command executes PowerShell scripts with full environment control and configurable exit code handling. It works on Windows, Linux, and macOS.\nAttributes Required type: \"pwsh\": Identifies this as a PowerShell command name: Descriptive name for the command script OR script_file: PowerShell script content or path to script file (mutually exclusive) Optional working_directory: Directory to execute the command in env: Environment variables as key-value pairs runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution success_exit_codes: Exit codes indicating success (defaults to [0]) skip_exit_codes: Exit codes that skip remaining commands Inline Script Example name: \"PowerShell Inline\" commands: - type: \"pwsh\" name: \"Run PowerShell Script\" script: | Write-Host \"Starting PowerShell script...\" # Your PowerShell commands here Write-Host \"PowerShell script completed.\" Script File Example name: \"PowerShell File\" commands: - type: \"pwsh\" name: \"Run PowerShell File\" script_file: \"./scripts/deploy.ps1\" working_directory: \"/app\" Complete Example name: \"Advanced PowerShell Command\" commands: - type: \"pwsh\" name: \"Build and Deploy\" script: | Write-Host \"Building application...\" dotnet build -c Release Write-Host \"Running tests...\" dotnet test if ($LASTEXITCODE -ne 0) { Write-Error \"Tests failed\" exit 1 } Write-Host \"Deployment successful\" working_directory: \"/path/to/project\" env: DEPLOY_ENV: \"production\" API_KEY: \"secret-key\" success_exit_codes: [0] runs_on_condition: \"success\" Script vs Script File Use script for inline PowerShell code:",
    "tags": [],
    "title": "PowerShell Command",
    "uri": "/porch/commands/pwsh/index.html"
  },
  {
    "breadcrumb": "Porch Documentation \u003e Advanced Topics",
    "content": "Porch TUI (Terminal User Interface) Implementation Overview The Porch orchestration tool now includes a real-time Terminal User Interface (TUI) that provides live progress monitoring during command execution. This enhancement offers better visibility into complex workflows compared to traditional text-based output.\nFeatures Implemented ✅ Core TUI Infrastructure Event-driven progress system: Real-time progress events flow from executing commands to the TUI Channel-based reporters: Thread-safe progress reporting with proper resource cleanup Hierarchical progress contexts: Commands can report progress with full command path context ✅ Interactive TUI Display Real-time command tree: Shows the hierarchical structure of executing commands Status indicators: Visual icons for command states (⏳ pending, ⚡ running, ✅ success, ❌ failed) Live timing: Shows elapsed time for running and completed commands Keyboard controls: ‘q’ to quit, ‘r’ to refresh ✅ Progressive Command Support Progressive shell commands: Shell commands now support real-time progress reporting Progressive batch commands: Serial and parallel batches propagate progress events Backward compatibility: Existing commands work unchanged; TUI is opt-in ✅ CLI Integration TUI flag: --tui, -t, or --interactive enables the TUI mode Graceful fallback: If TUI can’t initialize, falls back to standard mode Clean shutdown: Proper cleanup of TUI and progress resources Usage Basic TUI Usage # Run with TUI ./porch run -f config.yaml --tui # Alternative flags ./porch run -f config.yaml -t ./porch run -f config.yaml --interactive # Standard mode (unchanged) ./porch run -f config.yaml Example YAML Configuration The TUI works with any existing Porch YAML configuration. Here’s an example that showcases the TUI features:\nname: Build Pipeline description: Demonstration of TUI capabilities commands: - type: serial name: Main Pipeline commands: - type: shell name: Setup command_line: echo \"Setting up...\" \u0026\u0026 sleep 1 - type: parallel name: Quality Checks commands: - type: shell name: Linting command_line: echo \"Running linter...\" \u0026\u0026 sleep 2 - type: shell name: Unit Tests command_line: echo \"Running tests...\" \u0026\u0026 sleep 3 - type: shell name: Build command_line: echo \"Building...\" \u0026\u0026 sleep 2 Architecture Progress Event System Commands → Reporter → Events → TUI Display Commands: Execute while emitting progress events Reporter: Thread-safe event routing Events: Structured event data (started, progress, output, completed, failed) TUI Display: Real-time tree view with bubbletea framework Key Components Progress Events (internal/progress/) Event: Core event structure with command path, type, and data Reporter: Interface for sending events ChannelReporter: Channel-based implementation for TUI NullReporter: No-op implementation for standard mode TransparentReporter: Pass-through for existing commands TUI System (internal/tui/) Model: Main TUI state and bubbletea model CommandNode: Tree structure for command hierarchy Runner: Orchestrates TUI and command execution TUIReporter: Bridges progress events to TUI updates Progressive Commands (internal/runbatch/) ProgressiveRunnable: Interface for progress-aware commands ProgressiveOSCommand: Shell commands with progress reporting ProgressiveSerialBatch: Serial execution with progress ProgressiveParallelBatch: Parallel execution with progress Testing The implementation includes comprehensive tests:\n# Run all tests go test ./internal/... # Run with race detector go test ./internal/... -race # Test specific packages go test ./internal/tui/... go test ./internal/progress/... go test ./internal/runbatch/... Examples Complex Workflow ./porch run -f examples/tui-demo.yaml --tui Implementation Status ✅ Completed Core progress event infrastructure TUI display with command tree and status indicators Progressive shell command implementation Progressive serial and parallel batch support CLI integration with TUI flag Thread-safe progress reporting Comprehensive test coverage Technical Details Thread Safety All progress reporters use proper synchronization Command tree updates are mutex-protected Race detector passes on all tests Resource Management Proper cleanup of goroutines and channels Graceful shutdown on context cancellation TUI resources cleaned up on exit Backward Compatibility Existing configurations work unchanged Non-TUI mode behavior is identical Progressive features are additive Dependencies Added github.com/charmbracelet/bubbletea: TUI framework github.com/charmbracelet/lipgloss: Styling for TUI The TUI implementation provides a solid foundation for real-time command monitoring while maintaining full backward compatibility with existing Porch workflows.",
    "description": "Porch TUI (Terminal User Interface) Implementation Overview The Porch orchestration tool now includes a real-time Terminal User Interface (TUI) that provides live progress monitoring during command execution. This enhancement offers better visibility into complex workflows compared to traditional text-based output.\nFeatures Implemented ✅ Core TUI Infrastructure Event-driven progress system: Real-time progress events flow from executing commands to the TUI Channel-based reporters: Thread-safe progress reporting with proper resource cleanup Hierarchical progress contexts: Commands can report progress with full command path context ✅ Interactive TUI Display Real-time command tree: Shows the hierarchical structure of executing commands Status indicators: Visual icons for command states (⏳ pending, ⚡ running, ✅ success, ❌ failed) Live timing: Shows elapsed time for running and completed commands Keyboard controls: ‘q’ to quit, ‘r’ to refresh ✅ Progressive Command Support Progressive shell commands: Shell commands now support real-time progress reporting Progressive batch commands: Serial and parallel batches propagate progress events Backward compatibility: Existing commands work unchanged; TUI is opt-in ✅ CLI Integration TUI flag: --tui, -t, or --interactive enables the TUI mode Graceful fallback: If TUI can’t initialize, falls back to standard mode Clean shutdown: Proper cleanup of TUI and progress resources Usage Basic TUI Usage # Run with TUI ./porch run -f config.yaml --tui # Alternative flags ./porch run -f config.yaml -t ./porch run -f config.yaml --interactive # Standard mode (unchanged) ./porch run -f config.yaml Example YAML Configuration The TUI works with any existing Porch YAML configuration. Here’s an example that showcases the TUI features:",
    "tags": [],
    "title": "TUI Implementation Details",
    "uri": "/porch/advanced/tui-implementation/index.html"
  },
  {
    "breadcrumb": "Porch Documentation \u003e Getting Started",
    "content": "Flow Control Porch provides sophisticated flow control mechanisms to handle complex execution scenarios, including conditional execution, error handling, and intentional skipping.\nConditional Execution Every command in Porch can specify when it should run using the runs_on_condition attribute. This allows you to create workflows that adapt to the results of previous commands.\nRun Conditions There are four run conditions available:\nCondition Description success Run only if all previous commands succeeded (default) error Run only if a previous command failed always Run regardless of previous command results exit-codes Run only if previous command exited with specific codes Example: Basic Conditions name: \"Conditional Workflow\" commands: - type: \"shell\" name: \"Primary Task\" command_line: \"make build\" # runs_on_condition defaults to \"success\" - type: \"shell\" name: \"Success Handler\" command_line: \"echo 'Build succeeded, deploying...'\" runs_on_condition: \"success\" - type: \"shell\" name: \"Error Handler\" command_line: \"echo 'Build failed, cleaning up...'\" runs_on_condition: \"error\" - type: \"shell\" name: \"Always Cleanup\" command_line: \"rm -rf temp/\" runs_on_condition: \"always\" Exit Code Conditions For fine-grained control, use exit-codes condition with runs_on_exit_codes:\nname: \"Exit Code Handling\" commands: - type: \"shell\" name: \"Check Database\" command_line: \"db-check.sh\" - type: \"shell\" name: \"Handle Warning\" command_line: \"echo 'Database has warnings'\" runs_on_condition: \"exit-codes\" runs_on_exit_codes: [1, 2] # Run on warning codes - type: \"shell\" name: \"Handle Critical Error\" command_line: \"echo 'Critical database error'\" runs_on_condition: \"exit-codes\" runs_on_exit_codes: [3, 4, 5] # Run on critical codes Skip Controls Porch allows commands to intentionally skip remaining tasks in the current batch using skip exit codes. This is useful for optional steps or early termination scenarios.\nSkip Exit Codes Define exit codes that should skip remaining commands using skip_exit_codes:\nname: \"Optional Steps\" commands: - type: \"serial\" name: \"Build Pipeline\" commands: - type: \"shell\" name: \"Check Prerequisites\" command_line: | if [ -z \"$DEPLOY_KEY\" ]; then echo \"DEPLOY_KEY not set. Skipping deployment.\" 1\u003e\u00262 exit 99 fi skip_exit_codes: [99] - type: \"shell\" name: \"Deploy\" command_line: \"deploy.sh\" # This will be skipped if previous command exits with 99 When a command exits with a skip code:\nThe command is marked as intentionally skipped Remaining commands in the same batch are skipped The workflow continues with commands at the next level The overall workflow does not fail Practical Skip Example name: \"Feature Flag Workflow\" commands: - type: \"shell\" name: \"Check Feature Flag\" command_line: | if [ \"$ENABLE_FEATURE_X\" != \"true\" ]; then echo \"Feature X is disabled. Skipping tests.\" 1\u003e\u00262 exit 100 fi skip_exit_codes: [100] - type: \"shell\" name: \"Run Feature X Tests\" command_line: \"npm run test:feature-x\" # Skipped if feature flag is not set - type: \"shell\" name: \"Deploy Feature X\" command_line: \"deploy-feature-x.sh\" # Also skipped if feature flag is not set Success Exit Codes By default, only exit code 0 indicates success. You can customize this using success_exit_codes:\nname: \"Custom Success Codes\" commands: - type: \"shell\" name: \"Run Tool\" command_line: \"my-tool.sh\" success_exit_codes: [0, 1, 2] # Exits 0, 1, or 2 are considered successful skip_exit_codes: [3] # Exit 3 skips remaining commands # Any other exit code is a failure Exit Code Priorities When a command exits, Porch evaluates exit codes in this order:\nSkip codes (skip_exit_codes): If matched, skip remaining commands Success codes (success_exit_codes): If matched, continue normally Default: Any other exit code is treated as a failure Error Handling Porch provides comprehensive error handling throughout the workflow:\nSerial Batch Errors In serial execution, an error stops subsequent commands unless they have runs_on_condition: \"error\" or runs_on_condition: \"always\":\nname: \"Error Handling in Serial\" commands: - type: \"serial\" name: \"Build and Test\" commands: - type: \"shell\" name: \"Build\" command_line: \"make build\" - type: \"shell\" name: \"Test\" command_line: \"make test\" # Skipped if Build fails - type: \"shell\" name: \"Cleanup on Error\" command_line: \"make clean\" runs_on_condition: \"error\" # Only runs if Build or Test fails - type: \"shell\" name: \"Always Log\" command_line: \"save-log.sh\" runs_on_condition: \"always\" # Always runs Parallel Batch Errors In parallel execution, all commands run simultaneously. Errors are collected and reported after all commands complete:\nname: \"Parallel Error Handling\" commands: - type: \"parallel\" name: \"Run All Tests\" commands: - type: \"shell\" name: \"Unit Tests\" command_line: \"npm run test:unit\" - type: \"shell\" name: \"Integration Tests\" command_line: \"npm run test:integration\" - type: \"shell\" name: \"E2E Tests\" command_line: \"npm run test:e2e\" # All three run concurrently # If any fail, the batch reports an error - type: \"shell\" name: \"Generate Report\" command_line: \"test-report.sh\" runs_on_condition: \"always\" # Runs regardless of test results Tolerating Errors You can make commands “tolerant” of failures by using success exit codes or run conditions:\nMethod 1: Success Exit Codes - type: \"shell\" name: \"Optional Linter\" command_line: \"optional-lint.sh\" success_exit_codes: [0, 1] # Both 0 and 1 are considered successful Method 2: Always Continue - type: \"serial\" name: \"Best Effort Tasks\" commands: - type: \"shell\" name: \"Task 1\" command_line: \"task1.sh\" - type: \"shell\" name: \"Task 2 (Best Effort)\" command_line: \"task2.sh\" success_exit_codes: [0, 1, 2, 3, 4, 5] # Any exit code up to 5 continues workflow - type: \"shell\" name: \"Task 3\" command_line: \"task3.sh\" # Will run even if Task 2 \"fails\" Complete Example Here’s a comprehensive example combining all flow control features:\nname: \"CI/CD Pipeline with Flow Control\" commands: - type: \"serial\" name: \"CI Pipeline\" commands: # Check if deployment is enabled - type: \"shell\" name: \"Check Deploy Flag\" command_line: | if [ \"$DEPLOY\" != \"true\" ]; then echo \"Deployment disabled. Skipping deploy steps.\" 1\u003e\u00262 exit 99 fi skip_exit_codes: [99] # Build the application - type: \"shell\" name: \"Build\" command_line: \"make build\" # Run tests (parallel) - type: \"parallel\" name: \"Tests\" commands: - type: \"shell\" name: \"Unit Tests\" command_line: \"make test-unit\" - type: \"shell\" name: \"Integration Tests\" command_line: \"make test-integration\" # Deploy (only if tests passed) - type: \"shell\" name: \"Deploy to Staging\" command_line: \"deploy.sh staging\" runs_on_condition: \"success\" # Rollback on deploy failure - type: \"shell\" name: \"Rollback\" command_line: \"rollback.sh\" runs_on_condition: \"error\" # Always send notification - type: \"shell\" name: \"Send Notification\" command_line: \"notify.sh\" runs_on_condition: \"always\" Key Takeaways Conditional execution allows workflows to adapt to previous command results Skip codes provide graceful early termination without failing the workflow Success codes let you define what “success” means for each command Run conditions (success, error, always, exit-codes) control when commands execute Serial batches stop on error unless explicitly handled Parallel batches run all commands and collect errors Combine these features to create robust, flexible workflows",
    "description": "Flow Control Porch provides sophisticated flow control mechanisms to handle complex execution scenarios, including conditional execution, error handling, and intentional skipping.\nConditional Execution Every command in Porch can specify when it should run using the runs_on_condition attribute. This allows you to create workflows that adapt to the results of previous commands.",
    "tags": [],
    "title": "Flow Control",
    "uri": "/porch/basics/flow-control/index.html"
  },
  {
    "breadcrumb": "Porch Documentation",
    "content": "Controlling Output Porch provides several ways to control the output and logging behavior of your workflows. This includes environment variables for logging, command-line flags for output formatting, and color control.\nLog Levels Porch uses structured logging with different log levels. Control the log level using the LOG_LEVEL environment variable.\nAvailable Log Levels Level Description When to Use DEBUG Detailed debugging information Development and troubleshooting INFO General informational messages Normal operation (default) WARN Warning messages Important but non-critical issues ERROR Error messages Error conditions only Setting Log Level # Set log level via environment variable export LOG_LEVEL=DEBUG porch run -f workflow.yaml # Or inline LOG_LEVEL=DEBUG porch run -f workflow.yaml # Production: Only errors LOG_LEVEL=ERROR porch run -f workflow.yaml Example Output by Level DEBUG level (most verbose):\nDEBUG: Starting workflow execution DEBUG: Creating command: Build Application DEBUG: command info path=/usr/bin/go cwd=/project args=[build -o app .] INFO: Running command: Build Application DEBUG: Command completed with exit code 0 INFO level (default):\nINFO: Running command: Build Application INFO: Command completed successfully ERROR level (least verbose):\nERROR: Command failed: Build Application Stdout and Stderr By default, Porch captures stdout and stderr from all commands. You can control what appears in the results using command-line flags.\nCommand-Line Flags # Include stdout in results porch run -f workflow.yaml --output-stdout porch run -f workflow.yaml --stdout # Exclude stderr from results porch run -f workflow.yaml --no-output-stderr porch run -f workflow.yaml --no-stderr # Include details for successful commands porch run -f workflow.yaml --output-success-details porch run -f workflow.yaml --success # Combine flags porch run -f workflow.yaml --stdout --success --no-stderr Default Behavior By default:\nStdout: Not included in output (unless --stdout is specified) Stderr: Included for failed commands and commands with skip exit codes Success details: Not included for successful commands (unless --success is specified) Example: Showing Stdout # Without --stdout $ porch run -f workflow.yaml ✓ Build Application (1.2s) # With --stdout $ porch run -f workflow.yaml --stdout ✓ Build Application (1.2s) stdout: Building main.go... Build completed successfully Example: Hiding Stderr # Default (stderr shown for errors) $ porch run -f workflow.yaml ✗ Linter (0.5s) - exit code 1 stderr: main.go:15: unused variable 'x' # With --no-stderr $ porch run -f workflow.yaml --no-stderr ✗ Linter (0.5s) - exit code 1 Example: Showing Success Details # Default (minimal output for success) $ porch run -f workflow.yaml ✓ Tests (5.2s) # With --success $ porch run -f workflow.yaml --success ✓ Tests (5.2s) exit code: 0 duration: 5.234s stderr: PASS coverage: 85.3% of statements Color Output Porch automatically detects terminal capabilities and displays colored output when supported.\nControlling Color # Force color output porch run -f workflow.yaml # Disable color output NO_COLOR=1 porch run -f workflow.yaml # Explicitly enable color (even if not a TTY) FORCE_COLOR=1 porch run -f workflow.yaml Color Indicators Porch uses colors to indicate command status:\nGreen (✓): Successful commands Red (✗): Failed commands Yellow (⚠): Commands with warnings or non-zero success codes Gray: Skipped commands Blue: Running commands (in TUI) Disabling Color for CI/CD Many CI/CD systems don’t support ANSI color codes. Disable color:\n# GitHub Actions - name: Run Porch run: NO_COLOR=1 porch run -f workflow.yaml # GitLab CI script: - export NO_COLOR=1 - porch run -f workflow.yaml Saving Results Save workflow results to a file for later review:\n# Save results porch run -f workflow.yaml --out results # View saved results porch show results # View with all options porch show results --stdout --success Results File Format Results are saved as JSON files containing:\nCommand hierarchy Exit codes Execution duration Stdout and stderr output Environment variables Working directories Output Formats Tree View (Default) ✓ Build and Test Workflow (10.5s) ✓ Setup Environment (0.1s) ✓ Quality Checks (5.2s) ✓ Run Tests (4.8s) ✓ Run Linter (2.1s) ✓ Build Process (5.2s) ✓ Build for Linux (2.1s) ✓ Build for macOS (1.8s) JSON Output Results files use JSON format for programmatic processing:\n{ \"name\": \"Build and Test Workflow\", \"status\": \"success\", \"duration\": \"10.5s\", \"commands\": [ { \"name\": \"Setup Environment\", \"status\": \"success\", \"exit_code\": 0, \"duration\": \"0.1s\" } ] } Redirecting Command Output Within commands, use shell redirection to control output:\n# Send to stderr - type: \"shell\" name: \"Warning\" command_line: \"echo 'Warning message' 1\u003e\u00262\" # Suppress all output - type: \"shell\" name: \"Silent Command\" command_line: \"command \u003e/dev/null 2\u003e\u00261\" # Redirect to file - type: \"shell\" name: \"Save Log\" command_line: \"command \u003e output.log 2\u003e\u00261\" # Conditional output to stderr with skip - type: \"shell\" name: \"Check Condition\" command_line: | if [ -z \"$VAR\" ]; then echo \"VAR not set, skipping\" 1\u003e\u00262 exit 99 fi skip_exit_codes: [99] Practical Examples Verbose Development Mode # Maximum verbosity for debugging LOG_LEVEL=DEBUG porch run -f workflow.yaml --stdout --success Clean CI/CD Output # Minimal output for CI/CD NO_COLOR=1 LOG_LEVEL=ERROR porch run -f workflow.yaml --no-stderr --out results Detailed Results Review # Save results with all details porch run -f workflow.yaml --out results --stdout --success # Review later with color porch show results --stdout --success Production Deployment # Only errors, save results for audit NO_COLOR=1 LOG_LEVEL=ERROR porch run -f workflow.yaml --out deploy-results --no-stderr Best Practices Use LOG_LEVEL=DEBUG for development: Get detailed information during development Use LOG_LEVEL=ERROR for production: Reduce noise in production logs Save results in CI/CD: Keep audit trail with --out results Disable color in CI/CD: Use NO_COLOR=1 to avoid escape sequences Use –stdout for debugging: See command output when troubleshooting Use –success for detailed analysis: Review timing and exit codes Redirect important messages to stderr: Makes them visible in default output Environment Variables Summary Variable Values Default Purpose LOG_LEVEL DEBUG, INFO, WARN, ERROR INFO Control logging verbosity NO_COLOR 1 or any value Not set Disable color output FORCE_COLOR 1 or any value Not set Force color output Command-Line Flags Summary Flag Shorthand Description --output-stdout --stdout Include stdout in results --no-output-stderr --no-stderr Exclude stderr from results --output-success-details --success Include details for successful commands --out \u003cfile\u003e Save results to file Related TUI - Interactive terminal user interface Flow Control - Understanding skip codes and errors Shell Command - Using redirection in commands",
    "description": "Controlling Output Porch provides several ways to control the output and logging behavior of your workflows. This includes environment variables for logging, command-line flags for output formatting, and color control.\nLog Levels Porch uses structured logging with different log levels. Control the log level using the LOG_LEVEL environment variable.",
    "tags": [],
    "title": "Output Control",
    "uri": "/porch/output/index.html"
  },
  {
    "breadcrumb": "Porch Documentation \u003e Commands",
    "content": "Serial Command The serial command executes a list of commands sequentially, where each command waits for the previous one to complete before starting.\nAttributes Required type: \"serial\": Identifies this as a serial batch command name: Descriptive name for the command batch Optional working_directory: Directory inherited by all child commands env: Environment variables inherited by all child commands runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution commands: List of commands to execute (either this or command_group) command_group: Reference to a named command group (either this or commands) Basic Example name: \"Build Pipeline\" commands: - type: \"serial\" name: \"Build Steps\" commands: - type: \"shell\" name: \"Install Dependencies\" command_line: \"npm install\" - type: \"shell\" name: \"Build\" command_line: \"npm run build\" - type: \"shell\" name: \"Test\" command_line: \"npm test\" Execution Flow In serial execution:\nCommands execute in the order defined Each command waits for the previous to complete If a command fails, subsequent commands are skipped (unless they have runs_on_condition: \"error\" or runs_on_condition: \"always\") Skip codes propagate through the serial batch - type: \"serial\" name: \"Sequential Tasks\" commands: - type: \"shell\" name: \"Task 1\" command_line: \"task1.sh\" # Runs first - type: \"shell\" name: \"Task 2\" command_line: \"task2.sh\" # Runs after Task 1 completes - type: \"shell\" name: \"Task 3\" command_line: \"task3.sh\" # Runs after Task 2 completes Environment and Working Directory Inheritance Child commands inherit environment variables and working directory:\n- type: \"serial\" name: \"Build Process\" working_directory: \"./app\" env: BUILD_MODE: \"production\" commands: - type: \"shell\" name: \"Build\" command_line: \"make build\" # Runs in ./app with BUILD_MODE=production - type: \"shell\" name: \"Test\" working_directory: \"tests\" command_line: \"make test\" # Runs in ./app/tests with BUILD_MODE=production Error Handling Use conditional execution for error handling:\n- type: \"serial\" name: \"Build with Error Handling\" commands: - type: \"shell\" name: \"Build\" command_line: \"make build\" - type: \"shell\" name: \"Test\" command_line: \"make test\" # Skipped if Build fails - type: \"shell\" name: \"Cleanup on Error\" command_line: \"make clean\" runs_on_condition: \"error\" # Only runs if Build or Test fails - type: \"shell\" name: \"Always Notify\" command_line: \"notify.sh\" runs_on_condition: \"always\" # Always runs Nested Batches Serial batches can contain other batches:\n- type: \"serial\" name: \"Complete Pipeline\" commands: - type: \"shell\" name: \"Setup\" command_line: \"setup.sh\" - type: \"parallel\" name: \"Quality Checks\" commands: - type: \"shell\" name: \"Tests\" command_line: \"make test\" - type: \"shell\" name: \"Lint\" command_line: \"make lint\" - type: \"shell\" name: \"Deploy\" command_line: \"deploy.sh\" runs_on_condition: \"success\" Using Command Groups Reference reusable command groups:\nname: \"Workflow with Command Groups\" command_groups: - name: \"build-steps\" commands: - type: \"shell\" name: \"Install\" command_line: \"npm install\" - type: \"shell\" name: \"Build\" command_line: \"npm run build\" commands: - type: \"serial\" name: \"Execute Build\" command_group: \"build-steps\" Best Practices Group related tasks: Use serial for tasks that must run in order Handle errors: Add error handlers with runs_on_condition: \"error\" Use always for cleanup: Ensure cleanup runs with runs_on_condition: \"always\" Set common env at batch level: Inherit environment variables to child commands Use descriptive names: Name each step clearly for better visibility Related Parallel Command - Execute commands concurrently Flow Control - Conditional execution and error handling Path Inheritance - Working directory resolution",
    "description": "Serial Command The serial command executes a list of commands sequentially, where each command waits for the previous one to complete before starting.\nAttributes Required type: \"serial\": Identifies this as a serial batch command name: Descriptive name for the command batch Optional working_directory: Directory inherited by all child commands env: Environment variables inherited by all child commands runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution commands: List of commands to execute (either this or command_group) command_group: Reference to a named command group (either this or commands) Basic Example name: \"Build Pipeline\" commands: - type: \"serial\" name: \"Build Steps\" commands: - type: \"shell\" name: \"Install Dependencies\" command_line: \"npm install\" - type: \"shell\" name: \"Build\" command_line: \"npm run build\" - type: \"shell\" name: \"Test\" command_line: \"npm test\" Execution Flow In serial execution:",
    "tags": [],
    "title": "Serial Command",
    "uri": "/porch/commands/serial/index.html"
  },
  {
    "breadcrumb": "Porch Documentation \u003e Commands",
    "content": "Parallel Command The parallel command executes a list of commands concurrently, allowing independent tasks to run simultaneously for optimal performance.\nAttributes Required type: \"parallel\": Identifies this as a parallel batch command name: Descriptive name for the command batch Optional working_directory: Directory inherited by all child commands env: Environment variables inherited by all child commands runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution commands: List of commands to execute (either this or command_group) command_group: Reference to a named command group (either this or commands) Basic Example name: \"Parallel Tests\" commands: - type: \"parallel\" name: \"Run All Tests\" commands: - type: \"shell\" name: \"Unit Tests\" command_line: \"go test ./...\" - type: \"shell\" name: \"Linting\" command_line: \"golangci-lint run\" - type: \"shell\" name: \"Security Scan\" command_line: \"gosec ./...\" Execution Flow In parallel execution:\nAll commands start simultaneously Commands run independently of each other The batch waits for all commands to complete If any command fails, the batch is marked as failed All commands run to completion regardless of individual failures - type: \"parallel\" name: \"Quality Checks\" commands: - type: \"shell\" name: \"Test Suite 1\" command_line: \"test-suite-1.sh\" # Starts immediately - type: \"shell\" name: \"Test Suite 2\" command_line: \"test-suite-2.sh\" # Starts immediately (concurrent with Suite 1) - type: \"shell\" name: \"Test Suite 3\" command_line: \"test-suite-3.sh\" # Starts immediately (concurrent with Suite 1 \u0026 2) Use Cases Parallel execution is ideal for:\nIndependent tests: Unit tests, integration tests, E2E tests Quality checks: Linting, security scans, code coverage Multi-platform builds: Building for different OS/architectures Concurrent operations: Tasks that don’t depend on each other name: \"Quality Assurance\" commands: - type: \"parallel\" name: \"Run All Checks\" commands: - type: \"shell\" name: \"Unit Tests\" command_line: \"npm run test:unit\" - type: \"shell\" name: \"Integration Tests\" command_line: \"npm run test:integration\" - type: \"shell\" name: \"ESLint\" command_line: \"npm run lint\" - type: \"shell\" name: \"TypeScript Check\" command_line: \"npm run type-check\" - type: \"shell\" name: \"Security Audit\" command_line: \"npm audit\" Error Handling All commands complete even if some fail:\n- type: \"parallel\" name: \"Best Effort Tests\" commands: - type: \"shell\" name: \"Test 1\" command_line: \"test1.sh\" # Continues even if other tests fail - type: \"shell\" name: \"Test 2\" command_line: \"test2.sh\" # Continues even if other tests fail # Next command runs after all parallel commands complete - type: \"shell\" name: \"Generate Report\" command_line: \"test-report.sh\" runs_on_condition: \"always\" # Runs whether parallel batch succeeded or failed Environment and Working Directory Child commands inherit from the parallel batch:\n- type: \"parallel\" name: \"Cross-Platform Builds\" working_directory: \"./dist\" env: BUILD_VERSION: \"1.0.0\" commands: - type: \"shell\" name: \"Linux Build\" command_line: \"build-linux.sh\" env: GOOS: \"linux\" # Runs in ./dist with BUILD_VERSION and GOOS - type: \"shell\" name: \"macOS Build\" command_line: \"build-macos.sh\" env: GOOS: \"darwin\" # Runs in ./dist with BUILD_VERSION and GOOS Nested Batches Combine parallel and serial execution:\n- type: \"parallel\" name: \"Multi-Service Pipeline\" commands: - type: \"serial\" name: \"Frontend Pipeline\" commands: - type: \"shell\" name: \"Build Frontend\" command_line: \"npm run build\" - type: \"shell\" name: \"Test Frontend\" command_line: \"npm test\" - type: \"serial\" name: \"Backend Pipeline\" commands: - type: \"shell\" name: \"Build Backend\" command_line: \"go build\" - type: \"shell\" name: \"Test Backend\" command_line: \"go test ./...\" Performance Considerations Parallel execution provides performance benefits when:\nTasks are I/O bound (network, disk) Tasks are independent (no shared state) System has multiple CPU cores # Fast: Parallel independent tasks - type: \"parallel\" name: \"Independent Downloads\" commands: - type: \"shell\" name: \"Download A\" command_line: \"wget url-a\" - type: \"shell\" name: \"Download B\" command_line: \"wget url-b\" # Better as serial: Dependent tasks - type: \"serial\" name: \"Dependent Tasks\" commands: - type: \"shell\" name: \"Build\" command_line: \"make build\" - type: \"shell\" name: \"Test\" command_line: \"make test\" # Needs build output Best Practices Use for independent tasks: Ensure tasks don’t depend on each other Limit concurrency: Don’t run too many resource-intensive tasks simultaneously Handle all errors: Use runs_on_condition: \"always\" for cleanup Consider system resources: Balance parallelism with available CPU/memory Use descriptive names: Clear names help identify which task failed Related Serial Command - Execute commands sequentially Flow Control - Conditional execution ForEach Directory - Parallel directory iteration",
    "description": "Parallel Command The parallel command executes a list of commands concurrently, allowing independent tasks to run simultaneously for optimal performance.\nAttributes Required type: \"parallel\": Identifies this as a parallel batch command name: Descriptive name for the command batch Optional working_directory: Directory inherited by all child commands env: Environment variables inherited by all child commands runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution commands: List of commands to execute (either this or command_group) command_group: Reference to a named command group (either this or commands) Basic Example name: \"Parallel Tests\" commands: - type: \"parallel\" name: \"Run All Tests\" commands: - type: \"shell\" name: \"Unit Tests\" command_line: \"go test ./...\" - type: \"shell\" name: \"Linting\" command_line: \"golangci-lint run\" - type: \"shell\" name: \"Security Scan\" command_line: \"gosec ./...\" Execution Flow In parallel execution:",
    "tags": [],
    "title": "Parallel Command",
    "uri": "/porch/commands/parallel/index.html"
  },
  {
    "breadcrumb": "Porch Documentation",
    "content": "Terminal User Interface (TUI) Porch includes a real-time Terminal User Interface (TUI) that provides live progress monitoring during command execution. The TUI offers better visibility into complex workflows compared to traditional text-based output.\nEnabling the TUI Use one of these flags to enable the TUI:\n# Using --tui flag porch run -f workflow.yaml --tui # Using -t shorthand porch run -f workflow.yaml -t # Using --interactive flag porch run -f workflow.yaml --interactive Features Real-Time Command Tree The TUI displays a hierarchical tree structure showing:\nCommand names: Clear identification of each command Status indicators: Visual icons showing command state Execution timing: Live elapsed time for running and completed commands Progress updates: Real-time progress as commands execute Status Indicators Icon Status Description ⏳ Pending Command waiting to execute ⚡ Running Command currently executing ✅ Success Command completed successfully ❌ Failed Command failed with error ⊘ Skipped Command intentionally skipped Keyboard Controls Key Action q Quit the TUI and stop workflow r Refresh the display ↑/↓ Scroll through command tree (if needed) Example TUI Output Build Pipeline ⚡ 5.2s ✅ Setup Environment 0.1s ⚡ Quality Checks 3.8s ⚡ Unit Tests 2.1s ✅ Linting 1.2s ⚡ Security Scan 0.5s ⏳ Build and Package ⏳ Build Application ⏳ Create Archive [q] Quit [r] Refresh When to Use the TUI Best Use Cases Long-running workflows: Monitor progress of builds, tests, or deployments\nporch run -f ci-pipeline.yaml --tui Complex parallel execution: See which parallel tasks are still running\nporch run -f parallel-tests.yaml --tui Interactive debugging: Watch workflow execution in real-time\nporch run -f workflow.yaml --tui Development: Get immediate feedback during workflow development\nporch run -f new-workflow.yaml --tui When NOT to Use the TUI CI/CD pipelines: Use standard output for log collection\n# CI/CD - Don't use --tui NO_COLOR=1 porch run -f workflow.yaml --out results Scripting: When output needs to be parsed\n# Scripting - Don't use --tui porch run -f workflow.yaml --out results.json Background jobs: TUI requires interactive terminal\n# Background - Don't use --tui nohup porch run -f workflow.yaml --out results \u0026 Architecture The TUI is built on the Bubble Tea framework and uses a sophisticated event-driven architecture:\nProgress Event System Commands → Reporter → Events → TUI Display Commands: Execute while emitting progress events Reporter: Thread-safe event routing via channels Events: Structured event data (started, progress, output, completed, failed) TUI Display: Real-time tree view updates Event Types The TUI responds to several event types:\nStarted: Command begins execution Progress: Command reports progress update Output: Command produces stdout/stderr Completed: Command finishes successfully Failed: Command fails with error Skipped: Command intentionally skipped Progressive Commands Commands that support real-time progress reporting:\nProgressive Shell Commands Shell commands report when they start and complete:\n- type: \"shell\" name: \"Long Running Build\" command_line: \"npm run build\" # TUI shows: ⏳ → ⚡ Running (with timer) → ✅ or ❌ Progressive Batch Commands Serial and parallel batches propagate progress from child commands:\n- type: \"parallel\" name: \"Run Tests\" commands: - type: \"shell\" name: \"Unit Tests\" command_line: \"npm test\" - type: \"shell\" name: \"Integration Tests\" command_line: \"npm run test:integration\" # TUI shows both tests running concurrently with individual timers Graceful Fallback If the TUI cannot initialize (e.g., not a TTY, terminal not supported):\nPorch automatically falls back to standard output mode No error is raised Workflow continues normally with text output # TUI fallback example porch run -f workflow.yaml --tui 2\u003e\u00261 | tee log.txt # Falls back to standard output because stdout is redirected Resource Management The TUI properly manages resources:\nGoroutines: Cleaned up on exit Channels: Properly closed after use Terminal: Restored to normal mode on exit Context: Respects cancellation signals Clean Shutdown Press q or Ctrl+C to quit:\nTUI closes gracefully Running commands receive cancellation signal Terminal is restored to normal state Partial results are displayed Combining with Output Flags TUI can be combined with result saving:\n# Use TUI for monitoring, save results for later porch run -f workflow.yaml --tui --out results # Review results later without TUI porch show results --stdout --success Thread Safety The TUI implementation is thread-safe:\nProgress reporters use proper synchronization Command tree updates are mutex-protected All tests pass with -race flag Example Workflows Development Workflow # Watch tests run in real-time porch run -f test-workflow.yaml --tui CI/CD Pipeline Monitoring # Monitor deployment locally porch run -f deploy.yaml --tui # In CI/CD (no TUI) porch run -f deploy.yaml --out deployment-results Debugging Failed Workflow # Run with TUI to see where it fails porch run -f broken-workflow.yaml --tui # See which command fails in real-time # Press 'q' to quit if needed Best Practices Use for interactive sessions: Perfect for local development and debugging Skip in CI/CD: Use standard output mode for automated environments Save results: Combine --tui with --out to save results Monitor long workflows: TUI is ideal for workflows that take several minutes Watch parallel execution: See which parallel tasks complete first Limitations Terminal required: Must run in an interactive terminal No piping: Output redirection disables TUI (fallback to standard mode) Screen space: Very large command trees may require scrolling Single workflow: TUI shows one workflow at a time Technical Details Dependencies The TUI uses these libraries:\nBubble Tea: TUI framework Lipgloss: Terminal styling Charmbracelet: Terminal utilities Implementation Key components:\ninternal/tui/model.go: Main TUI state and Bubble Tea model internal/tui/runner.go: Orchestrates TUI and command execution internal/progress/: Progress event system internal/runbatch/progressive.go: Progressive command implementations Testing Comprehensive test coverage:\n# Run TUI tests go test ./internal/tui/... go test ./internal/progress/... # Run with race detector go test -race ./internal/... Backward Compatibility The TUI is fully backward compatible:\nExisting workflows work unchanged TUI is opt-in via flags Non-TUI mode behavior is identical Progressive features are additive Related Output Control - Configure logging and output Flow Control - Understanding command execution Commands - All command types support the TUI",
    "description": "Terminal User Interface (TUI) Porch includes a real-time Terminal User Interface (TUI) that provides live progress monitoring during command execution. The TUI offers better visibility into complex workflows compared to traditional text-based output.\nEnabling the TUI Use one of these flags to enable the TUI:",
    "tags": [],
    "title": "Terminal User Interface (TUI)",
    "uri": "/porch/tui/index.html"
  },
  {
    "breadcrumb": "Porch Documentation",
    "content": "Advanced Topics This section covers advanced features and implementation details of Porch.\nTopics Circular Dependency Detection - Understanding command group validation TUI Implementation - Technical details of the TUI system",
    "description": "Advanced Topics This section covers advanced features and implementation details of Porch.\nTopics Circular Dependency Detection - Understanding command group validation TUI Implementation - Technical details of the TUI system",
    "tags": [],
    "title": "Advanced Topics",
    "uri": "/porch/advanced/index.html"
  },
  {
    "breadcrumb": "Porch Documentation \u003e Commands",
    "content": "ForEach Directory Command The foreachdirectory command executes commands in each directory found by traversing the filesystem. This is particularly useful for monorepos or multi-module projects.\nAttributes Required type: \"foreachdirectory\": Identifies this as a foreach directory command name: Descriptive name for the command mode: Execution mode (parallel or serial) depth: Directory traversal depth (0 for unlimited, 1 for immediate children only) include_hidden: Whether to include hidden directories (true or false) working_directory_strategy: How to set working directory (none, item_relative) Optional working_directory: Base directory to start traversal from env: Environment variables inherited by all child commands runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution commands: List of commands to execute in each directory (either this or command_group) command_group: Reference to a named command group (either this or commands) Basic Example name: \"Test All Modules\" commands: - type: \"foreachdirectory\" name: \"Run Module Tests\" working_directory: \"./packages\" mode: \"parallel\" depth: 1 include_hidden: false working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Test Package\" command_line: \"npm test\" Working Directory Strategy item_relative Sets the working directory to each found directory relative to the current directory:\n- type: \"foreachdirectory\" name: \"Build Each Module\" working_directory: \"./modules\" working_directory_strategy: \"item_relative\" mode: \"parallel\" depth: 1 include_hidden: false commands: - type: \"shell\" name: \"Build\" command_line: \"go build\" # Runs in ./modules/module1, ./modules/module2, etc. none Does not change the working directory; commands run in the parent’s working directory:\n- type: \"foreachdirectory\" name: \"Process Directories\" working_directory: \"./data\" working_directory_strategy: \"none\" mode: \"serial\" depth: 1 include_hidden: false commands: - type: \"shell\" name: \"Process Directory\" command_line: \"process-dir.sh $ITEM\" # $ITEM contains the directory path # Command runs in ./data (not in each subdirectory) Environment Variable: ITEM For each directory iteration, an environment variable ITEM is set to the path of the current directory:\n- type: \"foreachdirectory\" name: \"List Directories\" working_directory: \"./projects\" mode: \"serial\" depth: 1 include_hidden: false working_directory_strategy: \"none\" commands: - type: \"shell\" name: \"Show Directory\" command_line: \"echo 'Processing: $ITEM'\" # $ITEM will be \"project1\", \"project2\", etc. Execution Modes Parallel Mode Process all directories concurrently:\n- type: \"foreachdirectory\" name: \"Parallel Module Tests\" working_directory: \"./packages\" mode: \"parallel\" depth: 1 include_hidden: false working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Run Tests\" command_line: \"npm test\" # All packages tested simultaneously Serial Mode Process directories one at a time:\n- type: \"foreachdirectory\" name: \"Serial Module Builds\" working_directory: \"./packages\" mode: \"serial\" depth: 1 include_hidden: false working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Build Package\" command_line: \"npm run build\" # Packages built one after another Depth Control Depth 1 - Immediate Children Only - type: \"foreachdirectory\" name: \"Top Level Only\" working_directory: \"./src\" depth: 1 include_hidden: false mode: \"parallel\" working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Process\" command_line: \"process.sh\" # Only processes ./src/dir1, ./src/dir2 # Does NOT process ./src/dir1/subdir Depth 0 - Unlimited Recursion - type: \"foreachdirectory\" name: \"All Directories\" working_directory: \"./src\" depth: 0 include_hidden: false mode: \"parallel\" working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Find Go Modules\" command_line: \"test -f go.mod \u0026\u0026 go test ./...\" # Processes all directories at any depth Complete Example name: \"Monorepo Testing\" description: \"Test all modules in a monorepo structure\" commands: - type: \"foreachdirectory\" name: \"Test All Modules\" working_directory: \"./modules\" mode: \"parallel\" depth: 1 include_hidden: false working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Check for Tests\" command_line: | if [ ! -d ./tests ]; then echo \"No tests found in $(pwd)\" 1\u003e\u00262 exit 99 fi skip_exit_codes: [99] - type: \"shell\" name: \"Install Dependencies\" command_line: \"npm install\" - type: \"shell\" name: \"Run Tests\" command_line: \"npm test\" - type: \"shell\" name: \"Build Module\" command_line: \"npm run build\" Skip Pattern Use skip codes to skip directories without certain criteria:\n- type: \"foreachdirectory\" name: \"Build Go Modules\" working_directory: \"./services\" mode: \"parallel\" depth: 1 include_hidden: false working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Check for go.mod\" command_line: | if [ ! -f go.mod ]; then echo \"No go.mod in $ITEM, skipping\" 1\u003e\u00262 exit 100 fi skip_exit_codes: [100] - type: \"shell\" name: \"Build\" command_line: \"go build ./...\" Hidden Directories Control whether hidden directories (starting with .) are included:\n# Include hidden directories - type: \"foreachdirectory\" name: \"Process All\" working_directory: \".\" mode: \"parallel\" depth: 1 include_hidden: true # Includes .git, .github, etc. working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Process\" command_line: \"process.sh\" # Exclude hidden directories (recommended) - type: \"foreachdirectory\" name: \"Process Visible Only\" working_directory: \".\" mode: \"parallel\" depth: 1 include_hidden: false # Skips .git, .github, etc. working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Process\" command_line: \"process.sh\" Best Practices Use depth: 1 when possible: Prevents unexpected deep recursion Set include_hidden: false: Avoid processing system directories Use skip codes: Skip directories that don’t meet criteria Choose appropriate mode: Parallel for speed, serial for order Use item_relative strategy: Most common and intuitive behavior Access $ITEM variable: Use the ITEM environment variable in commands Common Use Cases Monorepo Package Testing - type: \"foreachdirectory\" name: \"Test All Packages\" working_directory: \"./packages\" mode: \"parallel\" depth: 1 include_hidden: false working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Run Package Tests\" command_line: \"npm test\" Multi-Service Deployment - type: \"foreachdirectory\" name: \"Deploy All Services\" working_directory: \"./services\" mode: \"serial\" depth: 1 include_hidden: false working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Build Docker Image\" command_line: \"docker build -t $ITEM .\" - type: \"shell\" name: \"Deploy Service\" command_line: \"kubectl apply -f deployment.yaml\" Related Path Inheritance - Working directory resolution Parallel Command - Concurrent execution Serial Command - Sequential execution Flow Control - Skip codes and conditional execution",
    "description": "ForEach Directory Command The foreachdirectory command executes commands in each directory found by traversing the filesystem. This is particularly useful for monorepos or multi-module projects.\nAttributes Required type: \"foreachdirectory\": Identifies this as a foreach directory command name: Descriptive name for the command mode: Execution mode (parallel or serial) depth: Directory traversal depth (0 for unlimited, 1 for immediate children only) include_hidden: Whether to include hidden directories (true or false) working_directory_strategy: How to set working directory (none, item_relative) Optional working_directory: Base directory to start traversal from env: Environment variables inherited by all child commands runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution commands: List of commands to execute in each directory (either this or command_group) command_group: Reference to a named command group (either this or commands) Basic Example name: \"Test All Modules\" commands: - type: \"foreachdirectory\" name: \"Run Module Tests\" working_directory: \"./packages\" mode: \"parallel\" depth: 1 include_hidden: false working_directory_strategy: \"item_relative\" commands: - type: \"shell\" name: \"Test Package\" command_line: \"npm test\" Working Directory Strategy item_relative Sets the working directory to each found directory relative to the current directory:",
    "tags": [],
    "title": "ForEach Directory Command",
    "uri": "/porch/commands/foreachdirectory/index.html"
  },
  {
    "breadcrumb": "Porch Documentation \u003e Commands",
    "content": "Copy to Temp Command The copycwdtotemp command copies the current working directory to a temporary location for isolated execution. This is useful for testing, building, or any operations that should not affect the source directory.\nAttributes Required type: \"copycwdtotemp\": Identifies this as a copy to temp command name: Descriptive name for the command Optional working_directory: Directory to copy (defaults to current working directory) env: Environment variables runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution Basic Example name: \"Isolated Build\" commands: - type: \"copycwdtotemp\" name: \"Create Isolated Environment\" working_directory: \".\" How It Works When copycwdtotemp executes:\nCreates a new temporary directory Copies all contents from the working directory to the temp directory Sets the working directory to the absolute path of the temp directory Subsequent commands inherit this temp directory path The temp directory is automatically cleaned up when the workflow completes.\nComplete Example name: \"Isolated Testing\" description: \"Run tests in isolated temporary directory\" commands: - type: \"serial\" name: \"Isolated Test Workflow\" commands: - type: \"copycwdtotemp\" name: \"Copy to Temp Directory\" working_directory: \"./src\" # Copies ./src to /tmp/porch-12345/src - type: \"shell\" name: \"Modify Files Safely\" command_line: \"echo 'test content' \u003e test.txt\" # Runs in temp directory, doesn't affect source - type: \"shell\" name: \"Run Tests\" command_line: \"go test ./...\" # Tests run in isolated environment - type: \"shell\" name: \"Generate Report\" command_line: \"go test -json ./... \u003e test-results.json\" # Results saved in temp directory Use Cases 1. Isolated Testing Test without affecting source files:\ncommands: - type: \"copycwdtotemp\" name: \"Create Test Environment\" - type: \"shell\" name: \"Run Destructive Tests\" command_line: \"npm test -- --coverage\" # Coverage files and test artifacts don't pollute source 2. Clean Builds Build in a clean environment:\ncommands: - type: \"copycwdtotemp\" name: \"Create Build Environment\" working_directory: \".\" - type: \"shell\" name: \"Clean Build\" command_line: \"make clean \u0026\u0026 make build\" # Build artifacts stay in temp directory 3. Temporary Modifications Make temporary changes safely:\ncommands: - type: \"copycwdtotemp\" name: \"Create Temp Copy\" - type: \"shell\" name: \"Modify Configuration\" command_line: \"sed -i 's/debug=true/debug=false/' config.yaml\" # Original config.yaml is unchanged - type: \"shell\" name: \"Test Production Config\" command_line: \"npm test\" 4. Package Generation Create distribution packages:\ncommands: - type: \"copycwdtotemp\" name: \"Prepare Package Directory\" working_directory: \"./dist\" - type: \"shell\" name: \"Remove Dev Files\" command_line: \"rm -rf *.map *.test.js\" - type: \"shell\" name: \"Create Archive\" command_line: \"tar -czf ../package.tar.gz .\" Working with Multiple Steps The temp directory path persists for subsequent commands:\n- type: \"serial\" name: \"Multi-Step Temp Workflow\" commands: - type: \"copycwdtotemp\" name: \"Step 1: Copy to Temp\" # Sets cwd to /tmp/porch-xyz/ - type: \"shell\" name: \"Step 2: Build\" command_line: \"make build\" # Runs in /tmp/porch-xyz/ - type: \"shell\" name: \"Step 3: Test\" command_line: \"make test\" # Runs in /tmp/porch-xyz/ - type: \"shell\" name: \"Step 4: Package\" command_line: \"tar -czf output.tar.gz .\" # Runs in /tmp/porch-xyz/ Path Inheritance copycwdtotemp sets an absolute path to the temp directory, breaking path inheritance:\n- type: \"serial\" name: \"Temp and Regular Mix\" working_directory: \"./project\" commands: - type: \"shell\" name: \"Before Temp\" command_line: \"pwd\" # Prints: ./project - type: \"copycwdtotemp\" name: \"Copy to Temp\" # Sets absolute path: /tmp/porch-abc123/ - type: \"shell\" name: \"In Temp\" command_line: \"pwd\" # Prints: /tmp/porch-abc123/ - type: \"shell\" name: \"Back to Project\" working_directory: \"/original/project/path\" command_line: \"pwd\" # Prints: /original/project/path Combining with ForEach Directory - type: \"foreachdirectory\" name: \"Test Each Module in Isolation\" working_directory: \"./modules\" mode: \"serial\" depth: 1 include_hidden: false working_directory_strategy: \"item_relative\" commands: - type: \"copycwdtotemp\" name: \"Copy Module to Temp\" # Each module gets its own temp directory - type: \"shell\" name: \"Run Module Tests\" command_line: \"npm test\" # Tests run in isolated temp copy Best Practices Use for isolation: When you need to modify files without affecting source Clean builds: Ensure builds start from a clean state Testing: Run destructive tests without risk Temporary modifications: Make config changes for testing Remember it’s temporary: Files in temp directory are lost after workflow Limitations Temporary files are deleted: Results are lost unless copied out Disk space: Copying large directories uses disk space Performance: Copying takes time for large directories Absolute path: Sets absolute path, breaking relative path inheritance Saving Results To save results from temp directory, copy them back:\n- type: \"serial\" name: \"Build and Save\" commands: - type: \"copycwdtotemp\" name: \"Copy to Temp\" working_directory: \".\" - type: \"shell\" name: \"Build\" command_line: \"make build\" - type: \"shell\" name: \"Copy Results Back\" working_directory: \"/original/path/dist\" command_line: \"cp /tmp/porch-*/build/* .\" # Copy build artifacts back to original location Related Path Inheritance - How working directories work Serial Command - Sequential execution Shell Command - Execute shell commands",
    "description": "Copy to Temp Command The copycwdtotemp command copies the current working directory to a temporary location for isolated execution. This is useful for testing, building, or any operations that should not affect the source directory.\nAttributes Required type: \"copycwdtotemp\": Identifies this as a copy to temp command name: Descriptive name for the command Optional working_directory: Directory to copy (defaults to current working directory) env: Environment variables runs_on_condition: When to run (success, error, always, exit-codes) runs_on_exit_codes: Specific exit codes that trigger execution Basic Example name: \"Isolated Build\" commands: - type: \"copycwdtotemp\" name: \"Create Isolated Environment\" working_directory: \".\" How It Works When copycwdtotemp executes:",
    "tags": [],
    "title": "Copy to Temp Command",
    "uri": "/porch/commands/copycwdtotemp/index.html"
  },
  {
    "breadcrumb": "Porch Documentation",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/porch/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Porch - A Portable Process Orchestration Framework porch is a sophisticated Go-based process orchestration framework designed for running and managing complex command workflows. It provides a flexible, YAML-driven approach to define, compose, and execute command chains with advanced flow control, parallel processing, and comprehensive error handling.\nIt was designed to solve the problem of orchestrating complex command workflows in a portable and easy-to-use manner. Its portability means that you can confidently run the same workflows locally, in CI/CD pipelines, or on any server without worrying about compatibility issues.\nFeatures at a Glance 🚀 Command Orchestration Serial Execution: Run commands sequentially with dependency management Parallel Execution: Execute independent commands concurrently for optimal performance Nested Batches: Compose complex workflows with serial and parallel command combinations Shell Commands: Execute any shell command with full environment control Directory Iteration: Execute commands across multiple directories with flexible traversal options 📋 Flexible Configuration YAML-Based Workflows: Define command chains using simple, readable YAML syntax Working Directory Management: Control execution context with per-command working directories Environment Variables: Set and inherit environment variables at any level Conditional Execution: Run commands based on success, failure, or specific exit codes Command Groups: Define reusable command sets that can be referenced by container commands 🛡️ Robust Error Handling Graceful Signal Handling: Proper SIGINT/SIGTERM handling with graceful shutdown Context-Aware Execution: Full context propagation for cancellation and timeouts Comprehensive Results: Detailed execution results with exit codes, stdout, and stderr Error Aggregation: Collect and report errors across complex command hierarchies Skip Controls: Configure commands to skip remaining tasks based on exit codes 🎨 Beautiful Output TUI: Real-time terminal user interface for live command progress monitoring Tree Visualization: Clear hierarchical display of command execution Colorized Output: Terminal-aware colored output for better readability Structured Results: JSON and pretty-printed result formatting Progress Tracking: Real-time execution status and progress indication Quick Start Installation Operating System Support Porch currently supports the following operating systems:\nLinux macOS Windows Install from Go modules go install github.com/matt-FFFFFF/porch@latest Build from source git clone https://github.com/matt-FFFFFF/porch.git cd porch make build Basic Workflow Create a YAML file defining your command workflow:\nname: \"Build and Test Workflow\" description: \"Complete CI/CD pipeline example\" commands: - type: \"shell\" name: \"Setup Environment\" command_line: \"echo 'Setting up build environment...'\" - type: \"parallel\" name: \"Quality Checks\" commands: - type: \"shell\" name: \"Run Tests\" command_line: \"go test ./...\" - type: \"shell\" name: \"Run Linter\" command_line: \"golangci-lint run\" - type: \"serial\" name: \"Build and Package\" commands: - type: \"shell\" name: \"Build Application\" command_line: \"go build -o app .\" Execute the workflow porch run -f workflow.yaml What’s Next? Getting Started - Learn the fundamentals of Porch Commands - Detailed documentation for each command type Output Control - Configure logging and output options TUI - Interactive terminal user interface License This project is licensed under the MIT License - see the LICENSE file for details.",
    "description": "Porch - A Portable Process Orchestration Framework porch is a sophisticated Go-based process orchestration framework designed for running and managing complex command workflows. It provides a flexible, YAML-driven approach to define, compose, and execute command chains with advanced flow control, parallel processing, and comprehensive error handling.\nIt was designed to solve the problem of orchestrating complex command workflows in a portable and easy-to-use manner. Its portability means that you can confidently run the same workflows locally, in CI/CD pipelines, or on any server without worrying about compatibility issues.",
    "tags": [],
    "title": "Porch Documentation",
    "uri": "/porch/index.html"
  },
  {
    "breadcrumb": "Porch Documentation",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/porch/tags/index.html"
  }
]
